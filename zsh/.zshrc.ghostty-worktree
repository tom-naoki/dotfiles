# Ghostty / GitWorktree のための設定
#
# 主な機能:
#   - Ghosttyのタブタイトルにリポジトリ名・ブランチ名を表示
#   - worktreeの場合はタブの背景色をブランチ名に応じて自動で色分け
#   - プロンプトにリポジトリ名・worktree情報を表示
#   - Cursor/VSCodeのタイトルバー色をworktreeごとに設定するヘルパー関数
# ====================

# oh-my-zshのタイトルフックを明示的に除去
# oh-my-zshはデフォルトでターミナルタイトルを上書きするため、
# このファイルで独自にタイトル管理するには先に除去が必要
# (.zshrc本体でoh-my-zshが先にsourceされている分のフックも含めて除去)
precmd_functions=(${precmd_functions:#termsupport_precmd})
preexec_functions=(${preexec_functions:#termsupport_preexec})

# ====================
# ユーティリティ関数
# ====================

# Git情報を取得する共通関数（プロンプトとタブタイトルで共有）
#
# 以下のグローバル変数にGitリポジトリの情報をセットする:
#   _GIT_REPO_NAME     : リポジトリのディレクトリ名
#   _GIT_BRANCH        : 現在のブランチ名
#   _GIT_CURRENT_DIR   : リポジトリルートからの相対パス
#   _GIT_AT_ROOT       : リポジトリルートにいるかどうか (true/false)
#   _GIT_IS_WORKTREE   : worktreeかどうか (true/false)
#   _GIT_MAIN_REPO_NAME: worktreeの場合、元リポジトリのディレクトリ名
#
# 戻り値: Gitリポジトリ内なら0、それ以外なら1
_git_repo_info() {
  if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]; then
    local repo_path=$(git rev-parse --show-toplevel)
    local git_dir=$(git rev-parse --git-dir 2>/dev/null)
    local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

    _GIT_REPO_NAME=$(basename "$repo_path")
    _GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    _GIT_CURRENT_DIR=$(pwd | sed "s|$repo_path/||")
    _GIT_AT_ROOT=false
    [ "$(pwd)" = "$repo_path" ] && _GIT_AT_ROOT=true
    _GIT_IS_WORKTREE=false
    _GIT_MAIN_REPO_NAME=""
    # git-dirとgit-common-dirが異なる場合はworktreeと判定
    # worktreeの場合、git-common-dirは元リポジトリの.gitディレクトリを指す
    # 絶対パスに変換してから比較（相対パスと絶対パスの混在を防ぐ）
    # 注意: $(cd ...) を使うとサブシェル内で chpwd_functions が発火し、
    # _ghostty_report_pwd が誤ったディレクトリを報告してしまうため、
    # zshの :A 修飾子（絶対パス変換+シンボリックリンク解決）を使用する
    local git_dir_abs="${git_dir:A}"
    local git_common_dir_abs="${git_common_dir:A}"
    if [ "$git_dir_abs" != "$git_common_dir_abs" ]; then
      _GIT_IS_WORKTREE=true
      _GIT_MAIN_REPO_NAME=$(basename "$(dirname "$git_common_dir_abs")")
    fi
    return 0
  else
    return 1
  fi
}

# ブランチ名からworktree用の背景色を決定する関数
#
# HSLカラーモデルを使い、ブランチ名のハッシュ値から色相(Hue)を決定する
# 彩度(S=40%)と明度(L=12%)は固定にして、暗い背景色を360色から選ぶ
# 同じブランチ名なら常に同じ色になるため、視覚的に区別しやすい
#
# 引数: $1 - ブランチ名
# 出力: "#rrggbb" 形式のカラーコード
_worktree_bg_color() {
  local branch="$1"
  local hash=$(echo -n "$branch" | cksum | cut -d' ' -f1)

  # Hue: 0-359（色相環をフルに使う）
  local h=$((hash % 360))
  # Saturation: 40%, Lightness: 12%（×10してスケーリング）
  local s1=400
  local l1=120

  # HSL → RGB 変換（整数演算、×1000スケール）
  # C = (1 - |2L - 1|) * S
  local two_l_minus_1=$((2 * l1 - 1000))
  [ $two_l_minus_1 -lt 0 ] && two_l_minus_1=$((-two_l_minus_1))
  local c=$(( (1000 - two_l_minus_1) * s1 / 1000 ))

  # H' = H / 60 → sector(0-5) + remainder(0-59)
  local sector=$((h / 60))
  local rem=$((h % 60))

  # X = C * (1 - |H' mod 2 - 1|)
  local x
  if [ $((sector % 2)) -eq 0 ]; then
    x=$((c * rem / 60))
  else
    x=$((c * (60 - rem) / 60))
  fi

  # (R1, G1, B1) based on sector
  local r1 g1 b1
  case $sector in
    0) r1=$c; g1=$x; b1=0 ;;
    1) r1=$x; g1=$c; b1=0 ;;
    2) r1=0; g1=$c; b1=$x ;;
    3) r1=0; g1=$x; b1=$c ;;
    4) r1=$x; g1=0; b1=$c ;;
    5) r1=$c; g1=0; b1=$x ;;
  esac

  # m = L - C/2
  local m=$((l1 - c / 2))

  # 0-255 に変換
  local r=$(( (r1 + m) * 255 / 1000 ))
  local g=$(( (g1 + m) * 255 / 1000 ))
  local b=$(( (b1 + m) * 255 / 1000 ))

  printf "#%02x%02x%02x" $r $g $b
}

# ====================
# Cursor / VSCode 連携
# ====================

# worktreeに .vscode/settings.json を生成してCursorタイトルバーの色を設定する
#
# ブランチ名に応じた背景色を算出し、.vscode/settings.json の
# workbench.colorCustomizations に titleBar の色を書き込む
# 既存の settings.json がある場合は jq でマージ、なければ新規作成
#
# 使い方: worktreeディレクトリで `_setup_worktree_vscode_color` を実行
# 現在は ~/.aliasrc の gtr-new から呼び出されている
_setup_worktree_vscode_color() {
  local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  if [ -z "$branch" ]; then
    echo "Error: ブランチ名を取得できませんでした" >&2
    return 1
  fi

  local bg_color=$(_worktree_bg_color "$branch")

  mkdir -p .vscode

  if [ -f .vscode/settings.json ] && command -v jq &>/dev/null; then
    # 既存の settings.json がありjqが使える場合はマージ
    local tmp=$(mktemp)
    jq --arg bg "$bg_color" '
      . * {
        "workbench.colorCustomizations": (
          (.["workbench.colorCustomizations"] // {}) * {
            "titleBar.activeBackground": $bg,
            "titleBar.activeForeground": "#cccccc"
          }
        )
      }
    ' .vscode/settings.json > "$tmp" && mv "$tmp" .vscode/settings.json
  else
    # 新規作成 or jqがない場合
    cat > .vscode/settings.json <<EOF
{
  "workbench.colorCustomizations": {
    "titleBar.activeBackground": "${bg_color}",
    "titleBar.activeForeground": "#cccccc"
  }
}
EOF
  fi

  echo "Cursor titleBar color: ${bg_color} (branch: ${branch})"
}

# worktree に mydocs ディレクトリを作成し、目的を記録する
#
# 使い方: worktree ディレクトリで `_setup_worktree_mydocs` を実行
# 現在は ~/.aliasrc の gtr-new から呼び出されている
_setup_worktree_mydocs() {
  local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

  mkdir -p mydocs

  local purpose
  if [ $# -gt 0 ]; then
    purpose="$1"
  else
    echo ""
    echo "この worktree でやりたいことを入力してください（空でEnterするとスキップ）:"
    echo ""
    read -r purpose
    echo ""
  fi

  # PR情報を取得
  local pr_section=""
  if command -v gh &>/dev/null; then
    local pr_info=$(gh pr list --head "$branch" --json title,url --limit 1 2>/dev/null)
    if [ -n "$pr_info" ] && [ "$pr_info" != "[]" ]; then
      local pr_title=$(echo "$pr_info" | jq -r '.[0].title')
      local pr_url=$(echo "$pr_info" | jq -r '.[0].url')
      if [ -n "$pr_title" ] && [ "$pr_title" != "null" ]; then
        pr_section="PR: [$pr_title]($pr_url)"
        echo "PR を検出しました: $pr_title"
      fi
    fi
  fi

  # worktree-info.md を作成
  cat > mydocs/worktree-info.md <<EOF
# INFO

**Branch:** $branch
**Created:** $(date '+%Y-%m-%d %H:%M')
EOF
  echo "mydocs/worktree-info.md を作成しました"

  if [ -n "$purpose" ] || [ -n "$pr_section" ]; then
    cat > mydocs/worktree-purpose.md <<EOF
# PURPOSE

$purpose
EOF
    if [ -n "$pr_section" ]; then
      cat >> mydocs/worktree-purpose.md <<EOF

$pr_section
EOF
    fi
    echo "mydocs/worktree-purpose.md を作成しました"
  else
    echo "mydocs/ ディレクトリを作成しました（purpose はスキップ）"
  fi

  # worktree-progress.md を作成
  cat > mydocs/worktree-progress.md <<EOF
# PROGRESS

- $(date '+%Y-%m-%d %H:%M') worktree作成
EOF
  echo "mydocs/worktree-progress.md を作成しました"

  # CLAUDE.local.md を作成（Claude Code への指示）
  cat > CLAUDE.local.md <<'EOF'
# Worktree Local Instructions

## 進捗更新

**ユーザーへの返答を完了するたびに**、必ず `mydocs/worktree-progress.md` を更新してください。
つまり、あなたがツール呼び出しを終えてユーザーにメッセージを返す直前に更新します。

### フォーマット
```
# PROGRESS

- YYYY-MM-DD HH:MM 進捗の1行サマリー
```

**時刻は必ず `date '+%Y-%m-%d %H:%M'` コマンドを実行して取得すること。推測や概算で書かないこと。**
**時刻の降順で並ぶように新しく追加する際は、上に追記すること。**

### 例
- リファクタを完了しました、確認してください
- 調査を開始する前に、確認してほしいことを投げています
- テストが通りました、PRレビューをお願いします
- エラーが発生中、調査中です
- プランが終わりました、確認お願いします

### 目的
この1行を見るだけで、ユーザーが次に何をすべきかわかるようにする。
EOF
  echo "CLAUDE.local.md を作成しました"

  # .claude/settings.local.json を作成（メインリポジトリの設定を引き継ぎ + worktree固有設定をマージ）
  mkdir -p .claude
  local main_root=$(_git_main_repo_root)
  local main_settings="$main_root/.claude/settings.local.json"

  if [ -f "$main_settings" ] && command -v jq &>/dev/null; then
    # メインリポジトリの settings.local.json をベースに、worktree固有設定をマージ
    jq '
      .permissions.allow = (.permissions.allow + ["Edit(mydocs/**)"] | unique)
      | .plansDirectory = "./mydocs/plans"
    ' "$main_settings" > .claude/settings.local.json
    echo ".claude/settings.local.json を作成しました（メインリポジトリの設定を引き継ぎ）"
  else
    # メインリポジトリに設定がない、またはjqがない場合は最小限の設定で新規作成
    cat > .claude/settings.local.json <<'EOF'
{
  "permissions": {
    "allow": [
      "Edit(mydocs/**)"
    ]
  },
  "plansDirectory": "./mydocs/plans"
}
EOF
    echo ".claude/settings.local.json を作成しました（新規作成）"
  fi
}

# worktree 削除時に mydocs をアーカイブする
#
# 引数: $1 - worktree のパス
# 保存先: ~/Desktop/Workspace/deleted-worktree-docs/{org}/{repo}/{worktree名}_yyyymmdd/
_archive_worktree_mydocs() {
  local wt_path="$1"
  local mydocs_path="$wt_path/mydocs"

  if [ ! -d "$mydocs_path" ]; then
    return 0
  fi

  # リポジトリ名を取得（origin の org/repo 形式）
  local repo_name=$(cd "$wt_path" && git remote get-url origin 2>/dev/null | sed -E 's#\.git$##; s#.*[:/]([^/]+/[^/]+)$#\1#')
  # worktree 名（ディレクトリ名）
  local wt_name=$(basename "$wt_path")

  # worktree-* を除いたアーカイブ対象を収集
  local targets=()
  for f in "$mydocs_path"/*(N); do
    [[ "${f:t}" == worktree-* ]] && continue
    targets+=("$f")
  done

  # 対象ファイルがなければ何もしない
  if [ ${#targets[@]} -eq 0 ]; then
    return 0
  fi

  local archive_dir="$HOME/Desktop/Workspace/deleted-worktree-docs/${repo_name}/${wt_name}_$(date '+%Y%m%d')"

  mkdir -p "$archive_dir"
  for f in "${targets[@]}"; do
    cp -r "$f" "$archive_dir"/
  done

  echo "mydocs をアーカイブしました: $archive_dir"
}

# ====================
# プロンプト・タブタイトルのカスタマイズ
# ====================

# eastwood テーマのパス表示部分をカスタマイズする関数
#
# 表示パターン:
#   worktree（ルート）  : [wt:元リポ名]
#   worktree（サブディレクトリ）: [wt:元リポ名:相対パス]
#   通常リポ（ルート）  : [リポ名]
#   通常リポ（サブディレクトリ）: [リポ名:相対パス]
#   Git外              : [~/.../カレントパス]
custom_path_display() {
  if _git_repo_info; then
    if [ "$_GIT_IS_WORKTREE" = "true" ]; then
      if [ "$_GIT_AT_ROOT" = "true" ]; then
        echo "[%{$fg[yellow]%}wt%{$fg[cyan]%}:${_GIT_MAIN_REPO_NAME}]"
      else
        echo "[%{$fg[yellow]%}wt%{$fg[cyan]%}:${_GIT_MAIN_REPO_NAME}:${_GIT_CURRENT_DIR}]"
      fi
    else
      if [ "$_GIT_AT_ROOT" = "true" ]; then
        echo "[${_GIT_REPO_NAME}]"
      else
        echo "[${_GIT_REPO_NAME}:${_GIT_CURRENT_DIR}]"
      fi
    fi
  else
    echo "[%~]"
  fi
}

# Ghosttyタブタイトル & タブ背景色を設定する precmd フック
#
# コマンド実行のたびに呼ばれ、以下を行う:
#   - タブタイトルをリポジトリ名+ブランチ名に設定
#   - worktreeの場合はOSC 11でタブの背景色をブランチ固有の色に変更
#   - 通常リポジトリ/Git外ではOSC 111でデフォルト背景色にリセット
_set_terminal_title() {
  local title
  if _git_repo_info; then
    if [ "$_GIT_IS_WORKTREE" = "true" ]; then
      title="[wt:${_GIT_MAIN_REPO_NAME}] ${_GIT_BRANCH}"
      # worktreeの場合: ブランチ名に応じた背景色を設定
      local bg_color=$(_worktree_bg_color "$_GIT_BRANCH")
      printf "\e]11;${bg_color}\a"
    else
      title="[${_GIT_REPO_NAME}] ${_GIT_BRANCH}"
      # 通常リポジトリ: デフォルトの背景色にリセット
      printf "\e]111\a"
    fi
  else
    title="${(%):-%~}"
    # Git外: デフォルトの背景色にリセット
    printf "\e]111\a"
  fi
  print -Pn "\e]0;${title}\a"
}

precmd_functions+=(_set_terminal_title)

# ====================
# eastwood テーマの上書き設定
# ====================

# git_custom_status の表示フォーマット（ブランチ名を緑の[]で囲み、変更ありなら赤*を付ける）
ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg[green]%}["
ZSH_THEME_GIT_PROMPT_SUFFIX="]%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[red]%}*%{$fg[green]%}"
ZSH_THEME_GIT_PROMPT_CLEAN=""

# プロンプト: [カスタムパス表示][ブランチ名]$
PROMPT='%{$fg[cyan]%}$(custom_path_display)%{$reset_color%}$(git_custom_status)%B$%b '
